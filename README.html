<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HitAndSunk-2023</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="hit-and-sunk-battleship-on-ethereum">Hit and Sunk! (Battleship on Ethereum)</h1>
<p><strong>University of Pisa - P2P Systems and Blockchains</strong><br>
<strong>Final Project - Academic year 2022/2023</strong></p>
<p>As final project a decentralized implementation of the popular board game Battleship on the Ethereum blockchain has been developed. Traditional Battleship games are typically hosted on centralized servers, which introduce a level of dependency and potential trust issues. By migrating the game to a blockchain platform, <strong>we eliminate the need for a trusted intermediary</strong> and enable players to engage in the game with confidence, knowing that the rules are enforced by smart contracts and the outcome is transparently recorded on the public ledger.</p>
<h1 id="game-overview">Game Overview</h1>
<p>The following graph shows a visual representation of the functions used by players or the game contract itself. It illustrates how actions taken by players affect the game state. Each action is represented by an arrow labeled with the first letter of the player’s name (e.g., “B” for Bob). The edges without any letter instead represent state transitions performed by the game contract.</p>
<p><img src="https://i.imgur.com/cgbT6AT.jpeg" alt="game overview"></p>
<h2 id="deployment-phase">Deployment Phase</h2>
<p>Let’s consider a game involving two players, Alice and Bob. Alice is the challenger who initiates the game by creating it, and Bob is the opponent who joins the game.<br>
In this phase, both players go through the following steps:</p>
<ol>
<li>
<p><strong>Deployment of Ships</strong>: each player strategically deploys its ships onto the game board, considering their tactics and game strategy. The game board is represented as an NxN matrix (where N is a power of 2), where each cell represents a potential location for a ship. The players place their ships by marking the cells as either occupied [1] or empty [0], based on their desired ship placement.</p>
</li>
<li>
<p><strong>Linearization of the Board and Seeds</strong>: the board is then linearized into a one-dimensional array. This process converts the two-dimensional structure of the board into a linear sequence of cells, simplifying subsequent operations. Additionally, an array of the same length is generated, containing random number seeds (0-255) . These seed array will be used as an entropy mask for the next step, ensuring added security.</p>
</li>
<li>
<p><strong>Hashing and Merkle Tree Computation</strong>: a new array is generated by taking the summation of values at the same index from the linearized board array and the seed array. This new array is then hashed, and the resulting hash values are used as leaves to construct a Merkle Tree (by chosing N as a power of 2, the tree is complete). The Merkle tree is constructed by recursively hashing the intermediate nodes until a single root value, known as the <code>merkleRoot</code>, is obtained. Basically will serve as a cryptographic proof of the entire state of the game board, providing a means to verify the integrity of the board.</p>
</li>
</ol>
<p><strong>"But what if one player wants to cheat on the structure of the board in some way?"</strong></p>
<p>Alice could construct the Merkle tree using an invalid board, even the empty one (filled of zeroes), where ships dimensions, counts, or directions are not valid. That’s why the contract through its constructor and constants establish the rules related to ships allowed. These rules serve as a reference for players to construct their boards correctly, making also to decouple the front-end or interface used to interact with the contract.</p>
<p><img src="https://imgur.com/jVCrRIR.jpeg" alt="coded game rules"></p>
<p>Each player condense its ship placement information into a string called <code>shipsPosition</code>, which consists of concatenated substrings, each representing a tuple that describes the core info of a ship positioning:</p>
<p><strong>&lt;<code>ship orientation ("H" or "V")</code>,<code>occupied row/column</code>, <code>starting column/row</code>, <code>ship length</code>&gt;</strong></p>
<p>To enhance security, the <code>shipsPosition</code> string is further combined with an entropy mask or seed value before being hashed, resulting in the <code>shipsPositionHashed</code> value. Basically this process follow a commit-reveal approach, ensuring ensures that the original board remains hidden until it needs to be verified. By storing the commitment and later comparing it with the revealed board, the contract can verify the integrity and authenticity of the board without revealing the board prematurely.</p>
<p>By storing both the <code>merkleRoot</code> and <code>shipsPositionHashed</code>, the contract can validate the correctness move-by-move during the Play Phase and will be able to verify the legitimacy of the winning player’s board in the Validation Phase.</p>
<p>Back to the game, Alice, as the challenger, choose a bet and calls the contract function <strong><code>CreateGame(betAmount, merkleRoot of her board, shipsPositionHashed of her board)</code></strong> . Bob, the opponent, can then join the game by calling the function <strong><code>JoinGame(gameId, merkleRoot of his board, shipsPositionHashed of his board)</code></strong>. Bob is required to pay the same bet amount to participate.</p>
<p>Once the game is created by Alice and Bob successfully joins it, the Play Phase is triggered when Bob, the opponent, launches the first torpedo.</p>
<h4 id="—-other-reachable-ending-states-">— Other reachable ending states :</h4>
<p>The <strong><code>closeGame(gameId)</code></strong> function allows the challenger to terminate the game if no other player has joined yet. This results in the withdrawal of the bet and prevents any further actions from taking place.</p>
<p>The <strong><code>quitGame(gameId)</code></strong> function allows one of the players to voluntarily quit the game if no moves have been made yet. In this case, it leads to a tie, and both players receive a refund of their bets.</p>
<p>In the v2 Battleship, it could still be beneficial to consider additional consequences for the player who quits, such as a penalty or deduction from their bet. This penalty amount could be used to cover the game creation costs and mitigate potential frustrations for the remaining player.</p>
<h2 id="playing-phase">Playing Phase</h2>
<p><img src="https://imgur.com/oXKfZBi.jpeg" alt="torpedoLaunch"></p>
<p>During the Play Phase, players take turns making moves by calling the <code>launchTorpedo</code> function. This function takes the following parameters:</p>
<ul>
<li><code>gameId</code>: The unique identifier of the game in which the move is being made.</li>
<li><code>prevMoveProof</code>: The merkle proof of the previous move made by the opponent.</li>
<li><code>prevMoveResult</code>: The result of the previous move made by the opponent.</li>
<li><code>prevMoveSeed</code>: The seed value used in the previous move.</li>
<li><code>nextRow</code>: The row coordinate of the target cell for the current move.</li>
<li><code>nextColumn</code>: The column coordinate of the target cell for the current move.</li>
</ul>
<p>However, let’s focus on describing Alice’s move during this phase, as Bob’s move follows a symmetrical pattern, it consists of three steps:</p>
<ol>
<li>
<p><strong>Verification of the previous move (if its not the first move)</strong> : Alice submitted as parameter the result of previous opponent move, so the contract rebuilds the leaf, and uses it along with Alice’s stored <code>merkleRoot</code> and the supplied <code>prevMoveProof</code> to verify the accuracy of Alice’s claim. If Alice is lying, it would be able to detect the discrepancy.</p>
</li>
<li>
<p><strong>Game state update (if its not the first move)</strong> :  If the verification is successful, indicating that the previous move result is valid, the contract updates the game state accordingly and checks if it is last Alice’s hitbox. If so, it emits a <strong><code>GameFinished</code></strong> event to declare the game as finished and provides the necessary information such as the winning player’s address (Bob’s one) and a reason code (TO_CHEC_WIN). Otherwise the contract proceeds to emit a <strong><code>TorpedoResult</code></strong>, event that provides information about Bob’s previous move, enriched with the confirmed result.</p>
</li>
<li>
<p><strong>Writing the next move</strong>: the contract proceeds to write Alice’s move in the game’s state and emits a <strong><code>TorpedoLaunched</code></strong> event, which includes details about Alice’s move. Bob will stay prepared to count the losses and counterattack as now it’s his turn.</p>
</li>
</ol>
<p>These three steps ensure that the game progresses smoothly, but notice that <strong>a player may choose to stop playing if their next <strong><code>launchTorpedo</code></strong> would validate their opponent’s winning move</strong>, therefore a timer is implemented in the game tracking the duration since the last move and serves as an inactivity timer.</p>
<h4 id="—-other-reachable-ending-states--1">— Other reachable ending states :</h4>
<p>When a player detects their opponent’s inactivity, they can invoke the <strong><code>quitGame(gameId)</code></strong> function. This action allows the active player to claim victory due to their opponent’s inactivity, only if the timer has expired. By doing so, the game is concluded, and the player invoking the function is declared the winner.</p>
<p>However, if the inactivity timer has not yet expired the function call will be considered as a voluntarily quit and the win will be awarded to the opponent.</p>
<h2 id="validation-phase">Validation Phase</h2>
<p>This is the last crucial step in the game that determines the legitimacy of the win. During the Validation Phase, the winning player must execute the <code>confirmLegitWin</code> function, which performs a series of checks in order to do it.</p>
<p>The <code>confirmLegitWin</code> function requires the following parameters:</p>
<ul>
<li><code>gameId</code>: The unique identifier of the finished game that needs validation.</li>
<li><code>board</code>: An array containing the revealed board, where each element represents a cell on the board.</li>
<li><code>boardSeeds</code>: An array containing the seeds corresponding to each cell in the revealed board. These seeds are used to calculate the board root hash.</li>
<li><code>shipsPositions</code>: A string representing the revealed ship positions on the board.</li>
<li><code>shipsPositionSeed</code>: A string representing the seed associated with the revealed ship positions.</li>
</ul>
<p>Here’s an overview of the steps performed in the <code>confirmLegitWin</code> function:</p>
<ol>
<li>
<p><strong>Board Verification</strong>: The function verifies if the ships on the <code>board</code> are placed within the game grid boundaries, occupy the specified positions without any overlap, and have correct ship dimensions. If everything meets the game rules, the board is considered valid, and the validation process continues.</p>
</li>
<li>
<p><strong>Merkle Root Verification</strong>: The contract recalculates the merkle root using the <code>board</code> and <code>boardSeeds</code>. If the recalculated merkle root matches the one initially submitted by the winning player, it indicates that the board is same it committed in the beginning so the validation process continues.</p>
</li>
<li>
<p><strong>Ship Positions Verification</strong>: The contract recalculates the hash using the <code>shipsPositions</code> and <code>shipsPositionSeed</code> and if it matches the one initially submitted by the winning player, it indicates that the ships are the same he deployed initially on the board, further validating the commit-reveal mechanism.</p>
</li>
</ol>
<p>If all verification steps pass successfully, the function declares the win as legitimate, awards the win to the winning player, and updates the game status accordingly. However, if any of the verification steps fail, it indicates that the win is not legitimate. In such a case, the other player is declared as the winner.</p>
<h1 id="battleship-dapp">Battleship DAPP</h1>
<p><img src="https://i.imgur.com/ydrhe89.jpg" alt="Infrastructure "></p>
<h3 id="compilation-process-1-2">Compilation Process (1-2)</h3>
<p>To prepare the <code>Battleship.sol</code> contract for deployment and execution on Ganache blockchain emulator, the contract source code needs to be compiled into EVM bytecode. The compilation process has been performed using the Truffle development environment which includes a solidity compiler in it, <code>solc</code>, responsible for converting the contract into the EVM bytecode. The output of the compilation process is the bytecode representation of the <code>Battleship.sol</code> contract and the <code>Application Binary Interface (ABI)</code>.</p>
<h3 id="ganache-deployment-3-4">Ganache Deployment (3-4)</h3>
<p>The <code>Battleship.sol</code> contract is then deployed using Truffle and Ganache. Truffle’s deploy script creates a deployment transaction, inserting the contract bytecode into the DATA field and the transactor into the FROM’s one. The transaction is then sent to Ganache RPC-JSON port and inserted into the local mempool. After being mined, Truffle extracts the new public key associated with the contract. Now we are ready to interact with it.</p>
<h3 id="configfile.js">ConfigFile.js</h3>
<p><strong><code>[battleship/src/contract/configFile.js]</code></strong></p>
<p>In <code>ConfigFile.js</code>, the initial step has been to initialize the web3 provider by connecting to the local Ganache network using the WebSocket protocol. This WebSocket connection provides a full-duplex, persistent, and stateful connection between the application and Ganache, crucial to enable event subscription rather than relying on frequent polling.</p>
<p>Once the web3 provider is initialized, the next step is to create a contract instance. This is achieved by utilizing the <code>Battleship.sol</code>'s ABI, which contains contract’s functions signature and events definition. So, along with the contract’s public key, the ABI is provided to web3.js to generate the contract instance, which will act as a bridge between the JavaScript application and the deployed <code>Battleship.sol</code> contract, facilitating interaction with its functions and events.</p>
<h3 id="battleship-controller">Battleship Controller</h3>
<p><strong><code>[battleship/src/contract/battleshipController.js]</code></strong></p>
<p>The <code>Battleship Controller</code> plays a central role in the architecture of the Battleship, as it imports both web3 and contract instances in order to use them to define the contract interface. A key advantage of the <code>Battleship Controller</code> is its modular design, which encourages code reuse and simplifies the implementation of diverse client types. This modularity empowers the application to adapt to various user requirements and preferences with ease.</p>
<p>An excellent example of code reusability ,within the Battleship React application, is the mix of the React context with the <code>Battleship Controller</code> interface. This promotes code reuse let the entire app components to share the same interface.</p>
<h2 id="how-to-initialize-the-environment">How to initialize the environment:</h2>
<p>Just run the python script <strong><code>[ battleship/init_env.py ]</code></strong> and follow terminal instructions.</p>
<h2 id="contract">Contract</h2>
<p><strong><code>[ battleship/src/contract/deploy/contracts/battleship.sol ]</code></strong><br>
The provided code presents an implementation of the Battleship game on the Ethereum blockchain using Solidity. It enables two players to create and join games, strategically position their ships on the game board, and engage in turn-based attacks. The implementation aligns with the Game Overview described earlier and is accompanied by comprehensive comments that elucidate each step of the process.</p>
<h3 id="possible-vulnerabilities-and-solutions">Possible vulnerabilities and solutions</h3>
<ol>
<li>
<p><strong>Lack of Access Control</strong> : the issue of lack of access control has been resolved through the implementation of access control measures. Modifiers such as <code>canJoin</code>, <code>canMove</code>, and <code>canValidate</code> have been added to restrict access to function calling to specific roles but also to validate user inputs. These modifiers act as preconditions for executing certain functions, ensuring that only authorized players with the required roles can access sensitive functionality.</p>
</li>
<li>
<p><strong>Reentrancy Attacks</strong> : The reentrancy vulnerability arises when a contract allows an external contract to recursively invoke its own code. To address this vulnerability,  <code>a defense mechanism has been implemented using a combination of game.status and modifiers</code>. Prior to any modifications being made to the game data, the <code>game.status</code> value is altered, preventing the function from being called again. The modifiers effectively block reentrant calls, leveraging the change in <code>game.status</code>, thereby enhancing the overall protection.<br>
This behavior resembles that of a lock, ensuring that recursive invocations are prevented while critical operations are underway.</p>
</li>
<li>
<p><strong>Integer Overflow/Underflow</strong>: Solidity does not automatically check for integer overflows and underflows, which can lead to unexpected behavior. <code>The code uses the SafeMath library to prevent such issues by performing checks for arithmetic operations that depends on user-provided inputs</code>, ensuring that the calculations do not result in overflows or underflows.</p>
</li>
<li>
<p><strong>Front-running attack</strong> a protection to front-running attack consists in linking subsequential <code>launchTorpedo</code> moves, as the validation of the previous move’s first phase depends on previous one. To further enhance the security against front-running attacks, a new parameter will of <code>launchTorpedo</code>, namely the <code>toConfirmIndex</code>, will be introduced in Battleship v2. This parameter ensures that moves from the same player are confirmed in the intended order. By including <code>toConfirmIndex</code> as a parameter, the contract safeguards against potential manipulation by miners who might try to invert the order of move confirmations.</p>
</li>
<li>
<p><strong>Denial of Service (DoS) Attacks</strong> : DoS attacks aim to disrupt the normal functioning of a smart contract by consuming excessive resources or causing it to enter an infinite loop. The code does not contain any loops that can be easily exploited for DoS attacks.</p>
</li>
</ol>
<h3 id="costs-analysis">Costs analysis</h3>
<p>An analysis of the gas costs associated with the deployment and execution of contract functions was conducted, yielding the following key findings:</p>
<ul>
<li>
<p><strong>Initial deployment</strong>: The contract’s initial deployment resulted in a gas cost of 4,853,081.</p>
</li>
<li>
<p><strong><code>createGame</code></strong>: The gas cost for executing the <code>createGame</code> function was 228,176, encompassing code execution and state changes. This cost may increase as more games are added.</p>
</li>
<li>
<p><strong><code>joinGame</code></strong>: Executing the <code>joinGame</code> function resulted in a gas cost of 194,919, covering code execution and associated state changes. This cost may also increase with additional games.</p>
</li>
<li>
<p><strong><code>launchTorpedo</code></strong>: The gas cost for the <code>launchTorpedo</code> function ranged from 109,803 to 958,198, reflecting its computational complexity and resource requirements.</p>
</li>
<li>
<p><strong><code>confirmWin</code></strong>: The gas cost for the <code>confirmWin</code> function was 2,710,604, accounting for execution expenses and state changes required to confirm a win.</p>
</li>
</ul>
<p>Based on the provided gas costs, the total gas cost for a game would be 5,530,039 gas, calculated by summing the deployment gas cost (4,853,081) and the game gas cost (676,958).</p>
<p>Considering the current Ethereum Average Gas Price of 27.11 gwei as of 10/06/2023:<br>
Cost of the deploy ≈ 0.1316 ETH<br>
Cost of a single game ≈ 0.01834 ETH</p>
<h2 id="testing-script">Testing script</h2>
<p><strong><code>[ battleship/src/contract/test/test.js]</code></strong></p>
<p>The <code>test.js</code> script provides comprehensive testing coverage for the Battleship game implementation. It aims to test all possible scenarios, formalized by considering the game flow graph formalized above, such as:</p>
<ol>
<li>
<p><strong>Normal Game</strong>: This scenario represents a typical game where both players make valid moves, targeting each other’s ships. The script verifies that the game progresses correctly, updating the game state and determining the winner when appropriate.</p>
</li>
<li>
<p><strong>Challenger closes the game</strong>: In this scenario, the challenger closes the game before the opponent has a chance to join. The script ensures that the challenger is refunded their bet.</p>
</li>
<li>
<p><strong>A player quits before game starts</strong>: If a player quits before game before any moves are made, it results in a tie. The script tests this scenario and verifies that both players are refunded their bets.</p>
</li>
<li>
<p><strong>A player finds out that the opponent cheated</strong>: This scenario addresses a situation where the contract finds out that the player is cheating on opponent previous move result. The script determines that the cheater loses the game.</p>
</li>
<li>
<p><strong>A player voluntary quits the game</strong>: If a player decides to voluntarily quit the game after it has started, the opponent is declared the winner.</p>
</li>
<li>
<p><strong>A player claims the other player inactivity</strong>: When a player realizes that their opponent has become inactive and the abandon timer expires, the active player can quit the game and be declared the winner.</p>
</li>
<li>
<p><strong>A player lied on board, boardpositions or gave invalid board</strong>: If the player who wins the game is found to have lied about their board or ships’ positions, or if the board is determined to be invalid, the other player is declared the winner.</p>
</li>
</ol>
<p>To easily switch between different test scenarios and observe the behavior and outcome of the Battleship game contract, you can modify the <code>scenario</code> variable in line 158 with above item numbers.</p>
<h2 id="react-dapp">React Dapp</h2>
<p>This frontend app optimizes contract interactions by leveraging events for state updates and minimizing contract invocations to only writing operations. The formalization of the problem and the inclusion of necessary information within events brought several advantages:</p>
<ol>
<li>
<p><strong>Real-time updates</strong>: event subscription enables the app to <code>receive immediate notifications when relevant events are emitted</code> by the smart contract. Instead of relying on manual or periodic polling, the app is notified in real-time whenever important events occur.</p>
</li>
<li>
<p><strong>Efficiency</strong>: event scanning and subscription improves efficiency and scalability by <code>reducing the number of transactions, optimizing gas usage, and avoiding network congestion</code>, resulting in a more streamlined and scalable application architecture.</p>
</li>
<li>
<p><strong>Historical data</strong>: events stored on the blockchain and the design of contract event structures enable the retrieval of historical information and <code>reconstruction of the game's data at any given point</code>. This feature facilitates functionalities such as auditing, verification, and data analysis, contributing to a more robust and versatile game application.</p>
</li>
<li>
<p><strong>Decoupling frontend and backend</strong>: by relying on events, <code>we can separate concerns between frontend and backend</code> implementation. The frontend app listens to events emitted by the smart contract, while the backend focuses on executing the game logic and emitting events accordingly.</p>
</li>
</ol>
<p>However, there are some cons associated with this approach, many of them can be mitigated or are not significant issues due to the nature of the game’s state machine design, such as:</p>
<ol>
<li>
<p><strong>Complexity</strong>: implementing event scanning/subscription in a frontend app introduces complexity that needs to be carefully managed. This includes setting up event listeners, handling event filtering and processing.</p>
</li>
<li>
<p><strong>Event Ordering [SOLVED]</strong>:  by <code>implementing the battleship game as a cycle-less state machine</code> with clear event ordering and one-direction game phase shifts, <code>the challenges associated with event ordering can be overcome</code>. This approach ensures the accurate reconstruction of the game state, providing also a reliable and accurate representation of the game’s progression.</p>
</li>
<li>
<p><strong>Events indexed argument limitation [SOLVED]</strong>: (from <strong>doc. <a href="https://docs.soliditylang.org/en/v0.4.21/contracts.html#events">link</a></strong>) The limitation of events in Solidity, where only three parameters can be marked as “indexed,” can be addressed effectively. <code>By selectively indexing the challenger, opponent, and match ID, it is possible to overcome this limitation</code> and enable efficient searching and retrieval of game-related data based on these indexed fields. However, it’s important to note that if the game involves more than two players, this limitation could become a potential problem.</p>
</li>
<li>
<p><strong>Events scanning can be resource-intensive [CAN BE SOLVED]</strong>: Retrieving events by scanning the entire blockchain can be a resource-intensive process, requiring significant time and computational resources. It becomes more challenging as the size of the blockchain and the number of blocks to scan increases. However, in v.2 battleship <code>the block number will be included in the GameCreated and GameJoined to allow both clients to set a lower bound for event retrieval</code>.</p>
</li>
</ol>
<h3 id="getting-started-with-the-app"><strong>Getting Started with the App</strong></h3>
<p>The app follows an initialization process that involves creating a new account, funding it with Ether from a rich account, and saving the account’s public and private keys in local storage. This ensures that the new account has an initial balance to participate in the game. By utilizing a rich account for funding, users can start playing without needing their own Ether from the start.</p>
<p>To ensure the security and isolation of each user’s account, the app utilizes the browser’s local storage. The publicKey and privateKey generated for the account are stored locally, preventing the sharing of this information across different users or browsers. By storing the account details in local storage, each user can have their own separate account for interacting with the game and managing their funds.</p>
<p>To maintain the privacy and integrity of user accounts, it is recommended to use different browsers or utilize other solutions that provide isolated local storage spaces for each user. This prevents any overlap or sharing of account information and ensures that each user’s funds and interactions are kept separate and secure.</p>
<p><strong><code>To create a game</code></strong><code>, follow these step-by-step instructions:</code></p>
<ol>
<li>
<p><strong>Access the App</strong>: Open your web browser and enter the URL <code>http://localhost:3000/discovery</code> to access the app’s discovery page.</p>
</li>
<li>
<p><strong>Create a Game</strong>: On the discovery page, locate the bottom right corner of the screen. You will find a “+” button. Click on this button to create a new game.</p>
<p><img src="https://imgur.com/0SF45g1.jpg" alt="Create Game"></p>
</li>
<li>
<p><strong>Position Ships</strong>: to position your ships, use the drag and drop functionality. Select a ship and drag it to the desired location on the board.</p>
</li>
<li>
<p><strong>Choose the Bet</strong>: After positioning all the ships, you will have the option to choose a bet amount. Look for the bet selection area or input field. Enter an appropriate bet value based on the minimum bet requirement (e.g., the minimum bet is 0.1).</p>
</li>
</ol>
<p>Once the game has been created, the game contract will emit a “GameCreated” event. Other clients will listen for this event and display the new challenge on their respective interfaces. However, before setting up the event listener, the page will scan the blockchain for any “GameCreated” events, this ensures that no game will be hidden from other players.</p>
<p><strong><code>To join a game</code></strong><code>, follow these step-by-step instructions on the other browser:</code></p>
<ol>
<li>
<p><strong>Access the App</strong>: Open your web browser and enter the URL <code>http://localhost:3000/discovery</code> to access the app’s discovery page.</p>
</li>
<li>
<p><strong>Join a Game</strong>: On the discovery page, choose the game to join and click on the “Join” button to join the game.</p>
<p><img src="https://i.imgur.com/CiE2U7c.jpg" alt="Create Game"></p>
</li>
<li>
<p><strong>Position Ships</strong>: to position your ships, use the drag and drop functionality. Select a ship and drag it to the desired location on the board.</p>
</li>
</ol>
<p>Once both players have joined, the game starts.</p>
<p><strong><code>To play</code></strong><code>, follow these step-by-step instructions on the other browser:</code></p>
<ol>
<li>
<p><strong>Access the game</strong>: <code>http://localhost:3000/play/&lt;gameId&gt;</code> to access the game page.</p>
</li>
<li>
<p><strong>PLAY</strong>: Good luck!<img src="https://i.imgur.com/Ltv6kei.png" alt="Create Game"></p>
</li>
</ol>
</div>
</body>

</html>
